<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Star Catcher — Mobile Friendly (Joystick + Music + Sprites)</title>
<style>
  :root{ --bg:#071126; --panel:#0f1a2b; --accent:#ffd86b; --muted:rgba(255,255,255,0.65); }
  html,body{ height:100%; margin:0; background: linear-gradient(180deg,#071126 0%, #081233 60%, #081833 100%); font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; color:white; -webkit-user-select:none; user-select:none; overflow:hidden;}
  #gameWrap{ position:relative; width:100%; height:100vh; display:flex; align-items:stretch; justify-content:center; }
  canvas{ display:block; background:transparent; width:100%; height:100%; touch-action:none; }
  #hud{ position:absolute; top:12px; left:12px; right:12px; display:flex; gap:8px; justify-content:space-between; pointer-events:none; z-index:30;}
  .panel{ background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border-radius:12px; padding:8px 12px; font-weight:600; font-size:14px; display:inline-flex; gap:8px; align-items:center; pointer-events:auto;}
  #controlsMobile{ position:absolute; bottom:18px; left:0; right:0; display:flex; justify-content:space-between; align-items:center; padding:0 18px; z-index:40; pointer-events:none; }
  .btn{ pointer-events:auto; -webkit-tap-highlight-color: rgba(0,0,0,0); background:rgba(255,255,255,0.03); border:none; color:var(--muted); width:64px; height:64px; border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:24px; user-select:none; touch-action:none; transition:transform .06s ease; }
  .btn:active{ transform: scale(.95); }
  #leftGroup{ display:flex; gap:12px; align-items:center; }
  #rightGroup{ display:flex; gap:12px; align-items:center; }
  #modal{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); background:linear-gradient(180deg, rgba(0,0,0,0.55), rgba(255,255,255,0.02)); border-radius:14px; padding:18px; text-align:center; z-index:50; display:none; min-width:220px;}
  #modal h2{ margin:0 0 8px 0; font-size:22px; }
  #modal button{ margin-top:12px; padding:8px 12px; border-radius:10px; border:none; background:var(--accent); color:#111; font-weight:700; }
  #leader{ margin-top:10px; text-align:left; font-size:13px; color:var(--muted); }
  /* joystick */
  .joystick{
    position:absolute;
    bottom:18px;
    left:18px;
    width:140px;
    height:140px;
    border-radius:50%;
    z-index:41;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:auto;
    touch-action:none;
  }
  .joy-base{
    width:100%;
    height:100%;
    background:rgba(255,255,255,0.03);
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .joy-knob{
    width:56px;
    height:56px;
    border-radius:50%;
    background:linear-gradient(180deg,#ffffff11,#00000011);
    display:block;
    transform:translate(0,0);
    box-shadow:0 6px 18px rgba(0,0,0,0.35);
  }
  @media (min-width:900px){ .joystick{ display:none; } .hidden-desktop{ display:none; } }
  @media (max-width:900px){ .hidden-mobile{ display:none; } }
  /* small misc */
  #musicToggle{ pointer-events:auto; }
  .topRightControls{ display:flex; gap:8px; align-items:center; pointer-events:auto; }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="gameCanvas"></canvas>

  <div id="hud">
    <div class="panel small" id="infoLeft">Score: <span id="score">0</span> | Lives: <span id="lives">3</span></div>
    <div style="display:flex;gap:8px;">
      <div class="panel small" id="infoCenter">Level: <span id="level">1</span></div>
      <div class="panel small" id="infoRight">High: <span id="high">0</span></div>
      <div class="panel small topRightControls" style="align-items:center;gap:6px">
        <label style="display:flex;align-items:center;gap:6px">SFX <input id="toggleSound" type="checkbox" checked></label>
        <label style="display:flex;align-items:center;gap:6px">Music <input id="toggleMusic" type="checkbox" id="musicToggle" checked></label>
      </div>
    </div>
  </div>

  <!-- Mobile Controls: buttons (right) -->
  <div id="controlsMobile">
    <div id="leftGroup">
      <button id="btnLeft" class="btn">&#9664;</button>
      <button id="btnRight" class="btn">&#9654;</button>
    </div>
    <div id="rightGroup">
      <button id="btnAction" class="btn">&#9650;</button>
    </div>
  </div>

  <!-- Virtual joystick for mobile -->
  <div class="joystick" id="joystick">
    <div class="joy-base" id="joyBase">
      <div class="joy-knob" id="joyKnob"></div>
    </div>
  </div>

  <div id="modal">
    <h2 id="modalTitle">Game Over</h2>
    <div id="modalText">Score: <strong id="modalScore">0</strong></div>
    <div id="leader"></div>
    <button id="btnRestart">Restart</button>
  </div>
</div>

<script>
/* Star Catcher — Mobile edition with:
   - virtual joystick
   - background music + SFX toggles
   - SVG sprites embedded as data-URI
   - Optional Firebase leaderboard template (commented)
*/

const rand = (a,b) => a + Math.random()*(b-a);
const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
const pick = arr => arr[Math.floor(Math.random()*arr.length)];

// ---- sprite images as data URIs (SVG) ----
// You can replace these with your own image URLs for higher-quality art.
// Player sprite (simple ship)
const SPRITE_PLAYER = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
<svg xmlns="http://www.w3.org/2000/svg" width="120" height="80" viewBox="0 0 120 80">
  <defs><linearGradient id="g" x1="0" x2="1"><stop offset="0" stop-color="#7ee7ff"/><stop offset="1" stop-color="#4fa8ff"/></linearGradient></defs>
  <g>
    <ellipse cx="60" cy="60" rx="44" ry="14" fill="#06354a" />
    <path d="M12,60 C42,10 78,10 108,60" fill="url(#g)"/>
    <circle cx="60" cy="48" r="6" fill="#fff" opacity="0.9"/>
  </g>
</svg>`);

// Star sprite
const SPRITE_STAR = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
<svg xmlns="http://www.w3.org/2000/svg" width="90" height="90" viewBox="0 0 90 90">
  <polygon points="45,6 55,36 88,36 60,54 70,84 45,66 20,84 30,54 2,36 35,36" fill="#ffd86b"/>
  <filter id="g"><feGaussianBlur stdDeviation="0.7" /></filter>
</svg>`);

// Bomb sprite
const SPRITE_BOMB = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80">
  <circle cx="36" cy="44" r="22" fill="#2b2b2b"/>
  <rect x="50" y="16" width="8" height="16" rx="4" fill="#333"/>
  <path d="M58 10 c6 -6 14 -6 20 0" stroke="#ffcf6b" stroke-width="3" fill="none"/>
</svg>`);

// Power sprite (generic)
const SPRITE_POWER = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
<svg xmlns="http://www.w3.org/2000/svg" width="70" height="70" viewBox="0 0 70 70">
  <rect x="6" y="6" width="58" height="58" rx="8" fill="#5b9cff"/>
  <text x="35" y="43" font-size="30" font-family="Arial" text-anchor="middle" fill="#fff">P</text>
</svg>`);

// ---- canvas setup ----
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: true });
let DPR = Math.max(1, window.devicePixelRatio || 1);
function resize(){
  const w = window.innerWidth;
  const h = window.innerHeight;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * DPR);
  canvas.height = Math.floor(h * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resize);
resize();

// ---- state ----
let state = {
  score:0, lives:3, level:1, running:true, paused:false, high:0, sound:true, music:true
};
const HKEY = 'starcatcher_high_v2';
function loadHigh(){ try{ const r = localStorage.getItem(HKEY); return r?JSON.parse(r):[] }catch(e){return[]} }
function saveHigh(t){ localStorage.setItem(HKEY, JSON.stringify(t)); }
let highTable = loadHigh();
function updateHighDisplay(){ document.getElementById('high').textContent = highTable.length ? highTable[0].score : 0; }
updateHighDisplay();

// ---- player ----
const player = { x: innerWidth/2, y: innerHeight - 90, w:72, h:32, speed:420, vx:0, magnet:false, magnetUntil:0 };

// ---- items & particles ----
const items = [];
const particles = [];
let lastSpawn = 0, spawnInterval = 900;
let lastTime = performance.now();

// ---- audio: SFX + music ----
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
function playBeep(freq=440, dur=0.08, type='sine', vol=0.15){
  if(!state.sound) return;
  ensureAudio();
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
}
// background music: simple looped oscillator-based pad
let musicNode = null;
function startMusic(){
  if(!state.music) return;
  ensureAudio();
  if(musicNode) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.value = 110;
  g.gain.value = 0.02;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  musicNode = {osc:o,gain:g};
}
function stopMusic(){
  if(!musicNode) return;
  musicNode.osc.stop();
  musicNode = null;
}

// music toggle input
const soundToggle = document.getElementById('toggleSound');
soundToggle.addEventListener('change', ()=>{ state.sound = soundToggle.checked; });
const musicToggle = document.getElementById('toggleMusic');
musicToggle.addEventListener('change', ()=>{
  state.music = musicToggle.checked;
  // must resume audio context in response to user gesture on mobile
  if(state.music){
    ensureAudio();
    try{ audioCtx.resume(); }catch(e){}
    startMusic();
  } else stopMusic();
});

// resume audio on first touch/click so Chrome/Safari allow autoplay
function tryResumeAudio(){
  try{
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    if(state.music) startMusic();
  }catch(e){}
}
window.addEventListener('touchstart', tryResumeAudio, {once:true});
window.addEventListener('mousedown', tryResumeAudio, {once:true});

// ---- spawn logic ----
function spawnItem(){
  const w = innerWidth;
  const x = rand(24, w-24);
  const level = state.level;
  const t = Math.random();
  let type = 'star';
  if(t < 0.08 + (level*0.01)) type = 'bomb';
  else if(t < 0.14 + (level*0.01)) type = 'power';
  let subtype = null;
  if(type === 'power') subtype = pick(['life','slow','magnet']);
  items.push({
    id: Math.random().toString(36).slice(2,9),
    x, y:-30,
    vy: rand(80 + level*10, 160 + level*20),
    size: type === 'star'? rand(18,28) : type === 'bomb'? rand(22,30) : rand(20,26),
    type, subtype, angle: Math.random()*Math.PI*2, rotSpeed: rand(-0.03,0.03)
  });
}

// ---- particles ----
function spawnParticles(x,y,color,count=10){
  for(let i=0;i<count;i++){
    particles.push({ x,y, vx:rand(-220,220), vy:rand(-360,-80), life:rand(400,900), born:performance.now(), size:rand(2,6), color, alpha:1 });
  }
}

// ---- collisions ----
function rectIntersects(px,py,pw,ph,x,y,s){ return px < x+s && px+pw > x && py < y+s && py+ph > y; }

// ---- input: keyboard + on-screen buttons + swipe + joystick ----
const keys = {};
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft'||e.key==='a') keys.left=true;
  if(e.key==='ArrowRight'||e.key==='d') keys.right=true;
  if(e.key===' '||e.key==='ArrowUp') keys.action=true;
  if(e.key==='p') togglePause();
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft'||e.key==='a') keys.left=false;
  if(e.key==='ArrowRight'||e.key==='d') keys.right=false;
  if(e.key===' '||e.key==='ArrowUp') keys.action=false;
});

// on-screen buttons
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnAction = document.getElementById('btnAction');
let leftHeld=false,rightHeld=false,actionHeld=false;
['touchstart','mousedown'].forEach(ev=>{
  btnLeft.addEventListener(ev,(e)=>{ e.preventDefault(); leftHeld=true; tryResumeAudio(); }, {passive:false});
  btnRight.addEventListener(ev,(e)=>{ e.preventDefault(); rightHeld=true; tryResumeAudio(); }, {passive:false});
  btnAction.addEventListener(ev,(e)=>{ e.preventDefault(); actionHeld=true; tryResumeAudio(); }, {passive:false});
});
['touchend','mouseup','touchcancel','mouseleave'].forEach(ev=>{
  btnLeft.addEventListener(ev, ()=>{ leftHeld=false; }, {passive:true});
  btnRight.addEventListener(ev, ()=>{ rightHeld=false; }, {passive:true});
  btnAction.addEventListener(ev, ()=>{ actionHeld=false; }, {passive:true});
});

// swipe/tap on canvas
let touchStartX=null, touchStartY=null;
canvas.addEventListener('touchstart', (e)=>{ if(e.touches.length===0) return; touchStartX = e.touches[0].pageX; touchStartY = e.touches[0].pageY; }, {passive:true});
canvas.addEventListener('touchend', (e)=>{ if(touchStartX===null) return; const touch = e.changedTouches[0]; const dx = touch.pageX - touchStartX; const dy = touch.pageY - touchStartY; const dist = Math.sqrt(dx*dx + dy*dy); if(dist < 12){ triggerTapAction(touch.pageX, touch.pageY); } else { if(Math.abs(dx) > Math.abs(dy)){ if(dx>0) applySwipe('right'); else applySwipe('left'); } else { if(dy<0) applySwipe('up'); else applySwipe('down'); } } touchStartX=null; touchStartY=null; }, {passive:true});
canvas.addEventListener('mousedown', (e)=>{ triggerTapAction(e.pageX, e.pageY); });

// tap action
function triggerTapAction(x,y){ spawnParticles(x,y,'#ffd86b',6); playBeep(800,0.06,'sine',0.08); tryResumeAudio(); }

// swipe behavior
function applySwipe(dir){
  if(dir==='left'){ keys.left=true; setTimeout(()=>keys.left=false, 160); }
  if(dir==='right'){ keys.right=true; setTimeout(()=>keys.right=false,160); }
  if(dir==='up'){ keys.action=true; setTimeout(()=>keys.action=false,160); }
}

// joystick implementation
const joyBase = document.getElementById('joyBase');
const joyKnob = document.getElementById('joyKnob');
let joyActive=false, joyCenter={x:0,y:0}, joyId=null;
function initJoystick(){
  const rect = joyBase.getBoundingClientRect();
  joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
}
initJoystick();
window.addEventListener('resize', initJoystick);

function setKnobPos(x,y){
  const rect = joyBase.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;
  const max = rect.width/2 - 18;
  let dx = x - cx; let dy = y - cy;
  const d = Math.sqrt(dx*dx + dy*dy);
  if(d > max){ dx = dx * (max/d); dy = dy * (max/d); }
  joyKnob.style.transform = `translate(${dx}px, ${dy}px)`;
  // compute normalized direction
  const nx = dx / max;
  const ny = dy / max;
  // apply to keys (simple threshold)
  if(nx < -0.25) { keys.left = true; keys.right = false; } else if(nx > 0.25) { keys.right = true; keys.left = false; } else { keys.left = keys.right = false; }
}

function resetKnob(){ joyKnob.style.transform = 'translate(0,0)'; keys.left = false; keys.right = false; }

joyBase.addEventListener('pointerdown', (e)=>{
  joyActive=true; joyId=e.pointerId; joyBase.setPointerCapture(joyId);
  setKnobPos(e.clientX, e.clientY);
  tryResumeAudio();
});
joyBase.addEventListener('pointermove', (e)=>{
  if(!joyActive || e.pointerId !== joyId) return;
  setKnobPos(e.clientX, e.clientY);
});
joyBase.addEventListener('pointerup', (e)=>{
  if(e.pointerId !== joyId) return;
  joyActive=false; joyBase.releasePointerCapture(joyId); resetKnob();
});
joyBase.addEventListener('pointercancel', (e) => { if(e.pointerId === joyId) { joyActive=false; resetKnob(); } });

// map held buttons to keys periodically
setInterval(()=>{ keys.left = leftHeld || keys.left; keys.right = rightHeld || keys.right; keys.action = actionHeld || keys.action; }, 30);

// ---- gameplay functions ----
function nextLevel(){ state.level++; spawnInterval = Math.max(350, 900 - (state.level-1)*70); playBeep(1200,0.12,'sawtooth',0.18); spawnParticles(player.x, player.y-20, '#74ffb9', 30); updateUI(); }
function loseLife(){ state.lives--; playBeep(160,0.2,'sine',0.25); spawnParticles(player.x, player.y-10, '#ff6b6b', 18); if(state.lives <= 0) gameOver(); updateUI(); }
function applyPower(name){
  if(name==='life'){ state.lives++; playBeep(900,0.14,'triangle',0.18); spawnParticles(player.x, player.y-10, '#74ffb9',18); }
  else if(name==='slow'){ const old = spawnInterval; spawnInterval = spawnInterval * 1.7; playBeep(650,0.14,'sine',0.12); setTimeout(()=>{ spawnInterval = Math.max(350, old); }, 6000); }
  else if(name==='magnet'){ player.magnet=true; player.magnetUntil = performance.now() + 9000; playBeep(1400,0.12,'sine',0.12); }
  updateUI();
}

// ---- UI & leaderboard (local) ----
function updateUI(){ document.getElementById('score').textContent = state.score; document.getElementById('lives').textContent = state.lives; document.getElementById('level').textContent = state.level; }
const modal = document.getElementById('modal');
function gameOver(){
  state.running = false;
  document.getElementById('modalScore').textContent = state.score;
  modal.style.display = 'block';
  highTable.push({name:'You',score:state.score,date:(new Date()).toISOString()});
  highTable.sort((a,b)=>b.score-a.score);
  highTable = highTable.slice(0,10);
  saveHigh(highTable);
  renderLeader();
  updateHighDisplay();
}
document.getElementById('btnRestart').addEventListener('click', ()=>{ modal.style.display='none'; resetGame(); });

// render leaderboard inside modal
function renderLeader(){
  const el = document.getElementById('leader');
  el.innerHTML = '<strong>Top Scores</strong><br>';
  highTable.slice(0,5).forEach((it,i)=>{ el.innerHTML += `${i+1}. ${it.name} — ${it.score}<br>`; });
}

// reset game
function resetGame(){
  items.length = 0; particles.length = 0;
  state.score = 0; state.lives = 3; state.level = 1; state.running = true; state.paused=false;
  spawnInterval = 900; lastSpawn = 0;
  player.x = innerWidth/2; player.magnet=false;
  updateUI(); loop(performance.now());
}

// ---- main loop ----
function loop(ts){
  if(!lastTime) lastTime = ts;
  const dt = Math.min(60, ts - lastTime)/1000;
  lastTime = ts;
  if(!state.running) return;
  if(!state.paused){ update(dt); render(); } else { render(); ctx.fillStyle='rgba(2,6,12,0.45)'; ctx.fillRect(0,0,innerWidth,innerHeight); ctx.fillStyle='white'; ctx.font='22px Inter,system-ui'; ctx.textAlign='center'; ctx.fillText('Paused', innerWidth/2, innerHeight/2); }
  requestAnimationFrame(loop);
}

// ---- update ----
function update(dt){
  const now = performance.now();
  // movement
  let moveDir = 0;
  if(keys.left) moveDir -= 1;
  if(keys.right) moveDir += 1;
  if(moveDir !== 0) player.vx = player.speed * moveDir;
  else { player.vx *= 0.88; if(Math.abs(player.vx) < 2) player.vx = 0; }
  if(keys.action) spawnParticles(player.x, player.y-10, '#ffd86b', 2);
  player.x += player.vx * dt;
  player.x = clamp(player.x, player.w/2, innerWidth - player.w/2);
  player.y = innerHeight - 80;
  if(player.magnet && now > player.magnetUntil) player.magnet = false;
  if(now - lastSpawn > spawnInterval){ spawnItem(); lastSpawn = now; }
  for(let i=items.length-1;i>=0;i--){
    const it = items[i];
    it.y += it.vy * dt;
    it.angle += it.rotSpeed;
    if(player.magnet){
      const dx = player.x - it.x, dy = player.y - it.y, d = Math.sqrt(dx*dx + dy*dy);
      if(d < 180){ const s = 180 - d; it.x += (dx/(d||1))*(s*0.02); it.y += (dy/(d||1))*(s*0.02); }
    }
    if(rectIntersects(player.x - player.w/2, player.y - player.h/2 - 10, player.w, player.h, it.x - it.size/2, it.y - it.size/2, it.size)){
      if(it.type==='star'){ state.score += 10; spawnParticles(it.x,it.y,'#ffd86b',12); playBeep(1000+Math.random()*300,0.06,'square',0.08); }
      else if(it.type==='bomb'){ loseLife(); }
      else if(it.type==='power'){ applyPower(it.subtype); }
      items.splice(i,1);
      const lvlThreshold = 200 + state.level*200;
      if(state.score >= lvlThreshold) nextLevel();
      updateUI();
      continue;
    }
    if(it.y - it.size > innerHeight + 40){ if(it.type === 'star') state.score = Math.max(0, state.score - 5); items.splice(i,1); updateUI(); }
  }
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i]; const age = performance.now() - p.born;
    if(age > p.life){ particles.splice(i,1); continue; }
    const t = age / p.life;
    p.vy += 800 * dt; p.x += p.vx * dt; p.y += p.vy * dt; p.alpha = 1 - t;
  }
}

// ---- rendering ----
function clear(){
  ctx.clearRect(0,0,innerWidth,innerHeight);
  const grd = ctx.createLinearGradient(0,0,0,innerHeight);
  grd.addColorStop(0,'rgba(7,17,38,0.95)'); grd.addColorStop(1,'rgba(6,10,26,0.88)');
  ctx.fillStyle = grd; ctx.fillRect(0,0,innerWidth,innerHeight);
  // subtle starfield
  for(let i=0;i<35;i++){ ctx.globalAlpha = 0.05 + (i%7)*0.01; const sx = (i*97 + (performance.now()/40 % innerWidth)) % innerWidth; const sy = (i*53 + (performance.now()/80 % innerHeight)) % innerHeight; ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect(sx, sy, 1.2, 1.2); }
  ctx.globalAlpha = 1;
}
function drawPlayer(){
  const img = new Image(); img.src = SPRITE_PLAYER;
  const w = player.w, h = player.h*1.6;
  ctx.save(); ctx.translate(player.x, player.y); ctx.drawImage(img, -w/2, -h, w, h); ctx.restore();
  if(player.magnet){ ctx.beginPath(); ctx.strokeStyle='#74ffb9'; ctx.lineWidth=2; ctx.arc(player.x, player.y - player.h - 10, 18, 0, Math.PI*2); ctx.stroke(); }
}
function drawItems(){
  for(const it of items){
    ctx.save(); ctx.translate(it.x, it.y); ctx.rotate(it.angle);
    if(it.type === 'star'){ const img = new Image(); img.src = SPRITE_STAR; const s = it.size; ctx.drawImage(img, -s/2, -s/2, s, s); }
    else if(it.type === 'bomb'){ const img = new Image(); img.src = SPRITE_BOMB; const s = it.size; ctx.drawImage(img, -s/2, -s/2, s, s); }
    else if(it.type === 'power'){ const img = new Image(); img.src = SPRITE_POWER; const s = it.size; ctx.drawImage(img, -s/2, -s/2, s, s); ctx.fillStyle='white'; ctx.font = `${Math.floor(s*0.4)}px Inter`; ctx.textAlign='center'; ctx.textBaseline='middle'; }
    ctx.restore();
  }
}
function drawParticles(){ for(const p of particles){ ctx.globalAlpha = p.alpha || 1; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); } ctx.globalAlpha = 1; }
function drawHUD(){ if(window.innerWidth < 900){ ctx.font = '12px Inter, system-ui'; ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.textAlign = 'left'; ctx.fillText('Use joystick, arrows or swipe', 14, innerHeight - 12); } }
function render(){ clear(); drawItems(); drawPlayer(); drawParticles(); drawHUD(); }

// ---- start ----
resetGame();

// pause on visibility change
document.addEventListener('visibilitychange', ()=>{ if(document.hidden && state.running) state.paused = true; });

// UI tick
function uiTick(){ document.getElementById('score').textContent = state.score; document.getElementById('lives').textContent = state.lives; document.getElementById('level').textContent = state.level; requestAnimationFrame(uiTick); }
uiTick();

// ensure joystick hidden on desktop
function adaptUI(){ const mobileControls = document.getElementById('controlsMobile'); const joystick = document.getElementById('joystick'); if(window.innerWidth > 900){ mobileControls.style.display='none'; joystick.style.display='none'; } else { mobileControls.style.display='flex'; joystick.style.display='block'; } }
window.addEventListener('resize', adaptUI); adaptUI();

/* -------------------------
   OPTIONAL: Firebase leaderboard template
   -------------------------
   To enable an online leaderboard using Firebase Realtime Database or Firestore:
   1) Create a Firebase project at https://console.firebase.google.com/
   2) Add a Web App and copy the config.
   3) Uncomment and paste your config below, then implement simple writes/reads.

   Example (Firestore):
   import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
   import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from
   "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

   const firebaseConfig = { apiKey: "...", authDomain: "...", projectId: "...", storageBucket:"...", messagingSenderId:"...", appId:"..." };
   const app = initializeApp(firebaseConfig);
   const db = getFirestore(app);
   // to save:
   await addDoc(collection(db, "scores"), { name: "You", score: state.score, ts: new Date() });
   // to read top 10:
   const q = query(collection(db,"scores"), orderBy("score","desc"), limit(10));
   const snap = await getDocs(q);
   // then render list

   I left this as a template because it requires your project keys. If you'd like, paste your config and I can finish integrating it.
*/

// ---- helpful: small debug toggle ----
window.togglePause = ()=>{ state.paused = !state.paused; };

// ---- done ----
</script>
</body>
</html>

